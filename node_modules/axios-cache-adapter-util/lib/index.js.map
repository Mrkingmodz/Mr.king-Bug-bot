{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;GAEG;;;;AAIH,qEAAgC;AA6ChC,SAAgB,WAAW,CAAiC,KAA0B,EAAE,IAA0B,EAAE,OAAkB;IAErI,MAAM,EAAE,YAAY,GAAG,aAAyC,EAAC,GAAG,OAAO,IAAI,EAAE,CAAC;IAElF,OAAO,kBAAQ;SACb,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAyC,CAAC;SACrE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE;QAEhB,IAAI,CAAC,GAAG,YAAY,IAAI,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE3C,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,EAClB;YACC,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,EAC9B;gBACC,CAAC,GAAG,CAAC,CAAC;aACN;YAEA,KAAyB,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SACzC;IACF,CAAC,CAAC;SACD,UAAU,CAAC,KAAK,CAAC,CACjB;AACH,CAAC;AAtBD,kCAsBC;AAED,SAAgB,WAAW,CAAiG,KAA0B,EAAE,OAEvJ;IAEA,IAAI,OAAO,OAAO,KAAK,UAAU,EACjC;QACC,OAAO,GAAG;YACT,QAAQ,EAAE,OAAO;SACjB,CAAA;KACD;IAED,MAAM,IAAI,GAAM,EAAO,CAAC;IAExB,IAAI,EAAE,YAAY,GAAG,aAAyC,EAAE,QAAQ,EAAE,GAAG,OAAO,IAAI,EAAE,CAAC;IAE3F,IAAI,CAAC,QAAQ,EACb;QACC,QAAQ,GAAG,GAAG,EAAE,CAAC,IAAW,CAAC;KAC7B;IAED,OAAQ,KAAyB;SAC9B,OAAO,CAAC,UAAU,KAAmB,EAAE,GAAW;QAElD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAC7B;YACC,IACA;gBACC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;aAC1B;YACD,OAAO,CAAC,EACR;aAEC;SACD;QAED,IAAI,CAAC,GAAG,YAAY,IAAI,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAEjD,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,EAClB;YACC,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,EAC9B;gBACC,KAAK,GAAG,CAAC,CAAC;aACV;YAEA,IAAwB,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;SACvC;IAEF,CAAC,CAAC;SACF,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAM,CAAC,CAC9B;AACH,CAAC;AAlDD,kCAkDC;AAED;;;GAGG;AACH,SAAgB,eAAe,CAAC,EAA4B;IAE3D,aAAa;IACb,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;IAEvB,OAAO,GAAG,EAAE;QACX,aAAa;QACb,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,CAAA;IACxB,CAAC,CAAA;AACF,CAAC;AATD,0CASC;AAED,SAAgB,aAAa,CAAoD,CAAS,EAAE,CAAyB;IAEpH,MAAM,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC;IAE1B,OAAO,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG,CAAC;AACxD,CAAC;AALD,sCAKC;AAED,kBAAe;IACd,WAAW;IACX,WAAW;CACX,CAAA","sourcesContent":["/**\n * Created by user on 2019/6/11.\n */\n\nimport { setupCache, ISetupCache } from 'axios-cache-adapter';\nimport { ITSPickExtra, ITSRequireAtLeastOne, ITSResolvable, ITSValueOrArray } from 'ts-type';\nimport Bluebird from 'bluebird';\nimport { IResponseHeaders } from 'typed-http-headers';\n\nexport interface ICacheStoreJsonRow\n{\n\tstatus: number,\n\tstatusText: string | \"OK\",\n\theaders: IResponseHeaders | Record<string, unknown> | {\n\t\t'set-cookie'?: string[],\n\t},\n\tdata: string,\n}\n\nexport interface ICacheStoreJsonItem<T extends ICacheStoreJsonRow = ICacheStoreJsonRow>\n{\n\texpires: number,\n\tdata: T,\n}\n\nexport interface ICacheStoreJson<T extends ICacheStoreJsonRow = ICacheStoreJsonRow> extends Record<any, ICacheStoreJsonItem<T>>\n{\n\n}\n\nexport interface IOptions\n{\n\timportFilter?<T extends ICacheStoreJsonRow = ICacheStoreJsonRow>(k: string, v: ICacheStoreJsonItem<T>): boolean | number | ICacheStoreJsonItem<T>;\n\texportFilter?<T extends ICacheStoreJsonRow = ICacheStoreJsonRow>(k: string, v: ICacheStoreJsonItem<T>): boolean | number | ICacheStoreJsonItem<T>;\n}\n\nexport interface IBaseCacheStore\n{\n\tgetItem<T extends object>(key: string): Promise<T>;\n\tsetItem<T extends object>(key: string, value: T): Promise<T>;\n\n\tremoveItem(key: string): Promise<void>;\n\tclear(): Promise<void>;\n\n\tlength(): Promise<number>;\n\n\titerate(fn: (value: object | string, key: string) => ITSResolvable<any>): Promise<any>;\n\n\tstore?: ICacheStoreJson\n}\n\nexport function importCache<S extends ISetupCache[\"store\"]>(store: S | IBaseCacheStore, json: ICacheStoreJson<any>, options?: IOptions)\n{\n\tconst { importFilter = defaultFilter as IOptions[\"importFilter\"]} = options || {};\n\n\treturn Bluebird\n\t\t.resolve(Object.entries(json) as [string, ICacheStoreJsonItem<any>][])\n\t\t.each(([k, v]) =>\n\t\t{\n\t\t\tlet r = importFilter && importFilter(k, v);\n\n\t\t\tif (r || r == null)\n\t\t\t{\n\t\t\t\tif (r && typeof r === 'object')\n\t\t\t\t{\n\t\t\t\t\tv = r;\n\t\t\t\t}\n\n\t\t\t\t(store as IBaseCacheStore).setItem(k, v);\n\t\t\t}\n\t\t})\n\t\t.thenReturn(store)\n\t\t;\n}\n\nexport function exportCache<S extends ISetupCache[\"store\"], C extends ICacheStoreJson<unknown & ICacheStoreJsonRow>, R = C>(store: S | IBaseCacheStore, options?: ((json: C) => R) | IOptions & {\n\texportCb?(json: C): R;\n}): Promise<R>\n{\n\tif (typeof options === 'function')\n\t{\n\t\toptions = {\n\t\t\texportCb: options,\n\t\t}\n\t}\n\n\tconst json: C = {} as C;\n\n\tlet { exportFilter = defaultFilter as IOptions[\"exportFilter\"], exportCb } = options || {};\n\n\tif (!exportCb)\n\t{\n\t\texportCb = () => json as any;\n\t}\n\n\treturn (store as IBaseCacheStore)\n\t\t\t.iterate(function (value: any | string, key: string)\n\t\t\t{\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e)\n\t\t\t\t\t{\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet r = exportFilter && exportFilter(key, value);\n\n\t\t\t\tif (r || r == null)\n\t\t\t\t{\n\t\t\t\t\tif (r && typeof r === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = r;\n\t\t\t\t\t}\n\n\t\t\t\t\t(json as ICacheStoreJson)[key] = value;\n\t\t\t\t}\n\n\t\t\t})\n\t\t.then(r => exportCb(json) as R)\n\t\t;\n}\n\n/**\n * hook fn to process exit, return a fn for cancel\n * when process exit, can't take too many async , so if can try use sync\n */\nexport function processExitHook(fn: (...args: any[]) => void)\n{\n\t// @ts-ignore\n\tprocess.on('exit', fn);\n\n\treturn () => {\n\t\t// @ts-ignore\n\t\tprocess.off('exit', fn)\n\t}\n}\n\nexport function defaultFilter<T extends ICacheStoreJsonRow = ICacheStoreJsonRow>(k: string, v: ICacheStoreJsonItem<T>): boolean\n{\n\tconst { status } = v.data;\n\n\treturn status != 500 && status != 302 && status != 400;\n}\n\nexport default {\n\timportCache,\n\texportCache,\n}\n"]}