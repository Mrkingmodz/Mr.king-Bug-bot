{"version":3,"file":"LRUCache.js","sourceRoot":"","sources":["LRUCache.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tMAX,\n\tLENGTH_CALCULATOR,\n\tALLOW_STALE,\n\tMAX_AGE,\n\tDISPOSE,\n\tNO_DISPOSE_ON_SET,\n\tUPDATE_AGE_ON_GET,\n\tLENGTH,\n\tLRU_LIST,\n\tCACHE,\n} from './symbol';\nimport { naiveLength } from './naiveLength';\nimport { trim } from './ internal/trim';\nimport { forEachStep } from './ internal/forEachStep';\nimport Yallist from 'yallist';\nimport { isStale } from './ internal/isStale';\nimport { Entry } from './Entry';\nimport { get } from './ internal/get';\nimport { del } from './ internal/del';\nimport { IOptions, INode, IFn, ILruEntry } from './types';\n\n/**\n * lruList is a yallist where the head is the youngest\n * item, and the tail is the oldest.  the list contains the Hit\n * objects as the entries.\n * Each Hit object has a reference to its Yallist.Node.  This\n * never changes.\n *\n * cache is a Map (or PseudoMap) that matches the keys to\n * the Yallist.Node object.\n */\nexport class LRUCache<K, V>\n{\n\t/**\n\t * Kind of weird to have a default max of Infinity, but oh well.\n\t */\n\t[MAX]: number;\n\t[LENGTH_CALCULATOR]: (value: V, key?: K) => number;\n\t[ALLOW_STALE]: boolean;\n\t[MAX_AGE]: number;\n\t[DISPOSE]: (key: K, value: V) => void;\n\t[NO_DISPOSE_ON_SET]: boolean;\n\t[UPDATE_AGE_ON_GET]: boolean;\n\t/**\n\t * length of items in the list\n\t */\n\t[LENGTH]: number;\n\t/**\n\t * list of items in order of use recency\n\t */\n\t[LRU_LIST]: Yallist<Entry<K, V>>;\n\t/**\n\t * hash of items by key\n\t */\n\t[CACHE]: Map<K, INode<K, V>>\n\n\tconstructor(options?: IOptions<K, V> | number)\n\t{\n\t\tif (typeof options === 'number')\n\t\t{\n\t\t\toptions = { max: options }\n\t\t}\n\n\t\tif (!options)\n\t\t{\n\t\t\toptions = {}\n\t\t}\n\n\t\tif (options.max && (typeof options.max !== 'number' || options.max < 0))\n\t\t{\n\t\t\tthrow new TypeError('max must be a non-negative number')\n\t\t}\n\t\t// Kind of weird to have a default max of Infinity, but oh well.\n\t\tconst max = this[MAX] = options.max || Infinity\n\n\t\tconst lc = options.length || naiveLength\n\t\tthis[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n\t\tthis[ALLOW_STALE] = options.stale ?? false\n\t\tif (options.maxAge && typeof options.maxAge !== 'number')\n\t\t{\n\t\t\tthrow new TypeError('maxAge must be a number')\n\t\t}\n\t\tthis[MAX_AGE] = options.maxAge || 0\n\t\tthis[DISPOSE] = options.dispose\n\t\tthis[NO_DISPOSE_ON_SET] = options.noDisposeOnSet ?? false\n\t\tthis[UPDATE_AGE_ON_GET] = options.updateAgeOnGet ?? false\n\t\tthis.reset()\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * resize the cache when the max changes.\n\t * Same as Options.max. Resizes the cache when the `max` changes.\n\t */\n\tset max(mL)\n\t{\n\t\tif (typeof mL !== 'number' || mL < 0)\n\t\t{\n\t\t\tthrow new TypeError('max must be a non-negative number')\n\t\t}\n\n\t\tthis[MAX] = mL || Infinity\n\t\ttrim(this)\n\t}\n\n\t/**\n\t * resize the cache when the max changes.\n\t * Same as Options.max. Resizes the cache when the `max` changes.\n\t */\n\tget max()\n\t{\n\t\treturn this[MAX]\n\t}\n\n\t/**\n\t * Same as Options.allowStale.\n\t */\n\tset allowStale(allowStale)\n\t{\n\t\tthis[ALLOW_STALE] = !!allowStale\n\t}\n\n\t/**\n\t * Same as Options.allowStale.\n\t */\n\tget allowStale()\n\t{\n\t\treturn this[ALLOW_STALE]\n\t}\n\n\t/**\n\t * Same as Options.maxAge. Resizes the cache when the `maxAge` changes.\n\t */\n\tset maxAge(mA)\n\t{\n\t\tif (typeof mA !== 'number')\n\t\t{\n\t\t\tthrow new TypeError('maxAge must be a non-negative number')\n\t\t}\n\n\t\tthis[MAX_AGE] = mA\n\t\ttrim(this)\n\t}\n\n\t/**\n\t * Same as Options.maxAge. Resizes the cache when the `maxAge` changes.\n\t */\n\tget maxAge()\n\t{\n\t\treturn this[MAX_AGE]\n\t}\n\n\t/**\n\t * resize the cache when the lengthCalculator changes.\n\t * Same as Options.length.\n\t */\n\tset lengthCalculator(lC)\n\t{\n\t\tif (typeof lC !== 'function')\n\t\t{\n\t\t\tlC = naiveLength\n\t\t}\n\n\t\tif (lC !== this[LENGTH_CALCULATOR])\n\t\t{\n\t\t\tthis[LENGTH_CALCULATOR] = lC\n\t\t\tthis[LENGTH] = 0\n\t\t\tthis[LRU_LIST].forEach(hit =>\n\t\t\t{\n\t\t\t\thit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n\t\t\t\tthis[LENGTH] += hit.length\n\t\t\t})\n\t\t}\n\t\ttrim(this)\n\t}\n\n\t/**\n\t * resize the cache when the lengthCalculator changes.\n\t * Same as Options.length.\n\t */\n\tget lengthCalculator()\n\t{\n\t\treturn this[LENGTH_CALCULATOR]\n\t}\n\n\t/**\n\t * Return total length of objects in cache taking into account `length` options function.\n\t */\n\tget length()\n\t{\n\t\treturn this[LENGTH]\n\t}\n\n\tget size()\n\t{\n\t\treturn this[LENGTH]\n\t}\n\n\t/**\n\t * Return total quantity of objects currently in cache. Note,\n\t * that `stale` (see options) items are returned as part of this item count.\n\t */\n\tget itemCount()\n\t{\n\t\treturn this[LRU_LIST].length\n\t}\n\n\t/**\n\t * The same as `cache.forEach(...)` but items are iterated over in reverse order.\n\t * (ie, less recently used items are iterated over first.)\n\t */\n\trforEach(fn: IFn<K, V>, thisp?: LRUCache<K, V>)\n\t{\n\t\tthisp = thisp || this\n\t\tfor (let walker = this[LRU_LIST].tail; walker !== null;)\n\t\t{\n\t\t\tconst prev = walker.prev\n\t\t\tforEachStep(this, fn, walker, thisp)\n\t\t\twalker = prev\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Just like `Array.prototype.forEach`. Iterates over all the keys in the cache,\n\t * in order of recent-ness. (Ie, more recently used items are iterated over first.)\n\t */\n\tforEach(fn: IFn<K, V>, thisp?: LRUCache<K, V>)\n\t{\n\t\tthisp = thisp || this\n\t\tfor (let walker = this[LRU_LIST].head; walker !== null;)\n\t\t{\n\t\t\tconst next = walker.next\n\t\t\tforEachStep(this, fn, walker, thisp)\n\t\t\twalker = next\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Return an array of the keys in the cache.\n\t */\n\tkeys()\n\t{\n\t\treturn this[LRU_LIST].toArray().map(k => k.key)\n\t}\n\n\t/**\n\t * Return an array of the values in the cache.\n\t */\n\tvalues()\n\t{\n\t\treturn this[LRU_LIST].toArray().map(k => k.value)\n\t}\n\n\t/**\n\t * Clear the cache entirely, throwing away all values.\n\t */\n\treset()\n\t{\n\t\tif (this[DISPOSE] &&\n\t\t\tthis[LRU_LIST] &&\n\t\t\tthis[LRU_LIST].length)\n\t\t{\n\t\t\tthis[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n\t\t}\n\n\t\tthis[CACHE] = new Map() // hash of items by key\n\t\t// A linked list to keep track of recently-used-ness\n\t\tthis[LRU_LIST] = new Yallist() // list of items in order of use recency\n\t\tthis[LENGTH] = 0 // length of items in the list\n\n\t\treturn this\n\t}\n\n\tclear()\n\t{\n\t\treturn this.reset();\n\t}\n\n\t/**\n\t * Return an array of the cache entries ready for serialization and usage with `destinationCache.load(arr)`.\n\t */\n\tdump(): ILruEntry<K, V>[]\n\t{\n\t\treturn this[LRU_LIST].map(hit =>\n\t\t\tisStale(this, hit) ? null : {\n\t\t\t\tk: hit.key,\n\t\t\t\tv: hit.value,\n\t\t\t\te: hit.now + (hit.maxAge || 0),\n\t\t\t}).toArray().filter(h => h)\n\t}\n\n\tdumpLru()\n\t{\n\t\treturn this[LRU_LIST]\n\t}\n\n\t/**\n\t * Will update the \"recently used\"-ness of the key. They do what you think.\n\t * `maxAge` is optional and overrides the cache `maxAge` option if provided.\n\t */\n\tset(key: K, value: V, maxAge?: number)\n\t{\n\t\tmaxAge ||= this[MAX_AGE]\n\n\t\tif (maxAge && typeof maxAge !== 'number')\n\t\t{\n\t\t\tthrow new TypeError('maxAge must be a number')\n\t\t}\n\n\t\tconst now = maxAge ? Date.now() : 0\n\t\tconst len = this[LENGTH_CALCULATOR](value, key)\n\n\t\tif (this[CACHE].has(key))\n\t\t{\n\t\t\tif (len > this[MAX])\n\t\t\t{\n\t\t\t\tdel(this, this[CACHE].get(key))\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst node = this[CACHE].get(key)\n\t\t\tconst item = node.value\n\n\t\t\t// dispose of the old one before overwriting\n\t\t\t// split out into 2 ifs for better coverage tracking\n\t\t\tif (this[DISPOSE])\n\t\t\t{\n\t\t\t\tif (!this[NO_DISPOSE_ON_SET])\n\t\t\t\t{\n\t\t\t\t\tthis[DISPOSE](key, item.value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titem.now = now\n\t\t\titem.maxAge = maxAge\n\t\t\titem.value = value\n\t\t\tthis[LENGTH] += len - item.length\n\t\t\titem.length = len\n\t\t\tthis.get(key)\n\t\t\ttrim(this)\n\t\t\treturn true\n\t\t}\n\n\t\tconst hit = new Entry(key, value, len, now, maxAge)\n\n\t\t// oversized objects fall out of cache automatically.\n\t\tif (hit.length > this[MAX])\n\t\t{\n\t\t\tif (this[DISPOSE])\n\t\t\t{\n\t\t\t\tthis[DISPOSE](key, value)\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\n\t\tthis[LENGTH] += hit.length\n\t\tthis[LRU_LIST].unshift(hit)\n\t\tthis[CACHE].set(key, this[LRU_LIST].head)\n\t\ttrim(this)\n\t\treturn true\n\t}\n\n\tprotected _load_add(raw: ILruEntry<K, V>, maxAge?: number)\n\t{\n\t\tmaxAge ||= this[MAX_AGE]\n\n\t\tlet { k: key, v: value, e: now } = raw;\n\n\t\tconst len = this[LENGTH_CALCULATOR](value, key)\n\t\tlet hit = new Entry(key, value, len, now, maxAge)\n\n\t\tif (hit.length > this[MAX])\n\t\t{\n\t\t\tif (this[DISPOSE])\n\t\t\t{\n\t\t\t\tthis[DISPOSE](key, value)\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\n\t\tthis[LENGTH] += hit.length\n\t\tthis[LRU_LIST].unshift(hit)\n\t\tthis[CACHE].set(key, this[LRU_LIST].head)\n\t}\n\n\t/**\n\t * Check if a key is in the cache, without updating the recent-ness\n\t * or deleting it for being stale.\n\t */\n\thas(key: K)\n\t{\n\t\tif (!this[CACHE].has(key)) return false\n\t\tconst hit = this[CACHE].get(key).value\n\t\treturn !isStale(this, hit)\n\t}\n\n\t/**\n\t * Will update the \"recently used\"-ness of the key. They do what you think.\n\t * `maxAge` is optional and overrides the cache `maxAge` option if provided.\n\t *\n\t * If the key is not found, will return `undefined`.\n\t */\n\tget(key: K)\n\t{\n\t\treturn get(this, key, true)\n\t}\n\n\t/**\n\t * Returns the key value (or `undefined` if not found) without updating\n\t * the \"recently used\"-ness of the key.\n\t *\n\t * (If you find yourself using this a lot, you might be using the wrong\n\t * sort of data structure, but there are some use cases where it's handy.)\n\t */\n\tpeek(key: K)\n\t{\n\t\treturn get(this, key, false)\n\t}\n\n\tpop()\n\t{\n\t\tconst node = this[LRU_LIST].tail\n\t\tif (!node)\n\t\t{\n\t\t\treturn null\n\t\t}\n\n\t\tdel(this, node)\n\t\treturn node.value\n\t}\n\n\t/**\n\t * Deletes a key out of the cache.\n\t */\n\tdel(key: K)\n\t{\n\t\tlet value = this[CACHE].get(key);\n\t\tdel(this, value)\n\t\treturn value\n\t}\n\n\tdelete(key: K)\n\t{\n\t\treturn this.del(key)\n\t}\n\n\t/**\n\t * Loads another cache entries array, obtained with `sourceCache.dump()`,\n\t * into the cache. The destination cache is reset before loading new entries\n\t *\n\t * @param cacheEntries Obtained from `sourceCache.dump()`\n\t */\n\tload(arr: ILruEntry<K, V>[])\n\t{\n\t\t// reset the cache\n\t\tthis.reset()\n\n\t\tconst now = Date.now()\n\t\t// A previous serialized cache has the most recent items first\n\t\tfor (let l = arr.length - 1; l >= 0; l--)\n\t\t{\n\t\t\tconst hit = arr[l]\n\t\t\tconst expiresAt = hit.e || 0\n\t\t\tif (expiresAt === 0)\n\t\t\t\t// the item was created without expiration in a non aged cache\n\t\t\t{\n\t\t\t\t//this.set(hit.k, hit.v)\n\t\t\t\tthis._load_add(hit)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst maxAge = expiresAt - now\n\t\t\t\t// dont add already expired items\n\t\t\t\tif (maxAge > 0)\n\t\t\t\t{\n\t\t\t\t\t//this.set(hit.k, hit.v, maxAge)\n\t\t\t\t\tthis._load_add(hit, maxAge)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttrim(this)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Manually iterates over the entire cache proactively pruning old entries.\n\t */\n\tprune()\n\t{\n\t\tthis[CACHE].forEach((value, key) => get(this, key, false))\n\n\t\treturn this\n\t}\n\n\t* entries(): IterableIterator<[K, V]>\n\t{\n\t\tfor (let item of this[LRU_LIST])\n\t\t{\n\t\t\tyield [item.key as K, item.value as V]\n\t\t}\n\t\t//return this[LRU_LIST].toArray().entries()\n\t}\n\n\ttoArray()\n\t{\n\t\treturn this[LRU_LIST].toArray()\n\t}\n\n\t[Symbol.iterator]()\n\t{\n\t\treturn this.entries()\n\t}\n\n\tstatic create<K, V>(options?: IOptions<K, V> | number, arr?: ILruEntry<K, V>[])\n\t{\n\t\tlet lru = new this(options);\n\n\t\tif (arr?.length)\n\t\t{\n\t\t\tlru.load(arr)\n\t\t}\n\n\t\treturn lru\n\t}\n\n}\n"]}