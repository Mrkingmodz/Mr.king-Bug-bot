{"version":3,"file":"types.js","sourceRoot":"","sources":["types.ts"],"names":[],"mappings":"","sourcesContent":["import Yallist from 'yallist';\nimport { Entry } from './Entry';\nimport { LRUCache } from './LRUCache';\n\nexport interface IOptions<K, V>\n{\n\t/**\n\t * The maximum size of the cache, checked by applying the length\n\t * function to all values in the cache. Not setting this is kind of silly,\n\t * since that's the whole purpose of this lib, but it defaults to `Infinity`.\n\t */\n\tmax?: number;\n\n\t/**\n\t * Maximum age in ms. Items are not pro-actively pruned out as they age,\n\t * but if you try to get an item that is too old, it'll drop it and return\n\t * undefined instead of giving it to you.\n\t */\n\tmaxAge?: number;\n\n\t/**\n\t * Function that is used to calculate the length of stored items.\n\t * If you're storing strings or buffers, then you probably want to do\n\t * something like `function(n, key){return n.length}`. The default\n\t * is `function(){return 1}`, which is fine if you want to store\n\t * `max` like-sized things. The item is passed as the first argument,\n\t * and the key is passed as the second argument.\n\t */\n\tlength?(value: V, key?: K): number;\n\n\t/**\n\t * Function that is called on items when they are dropped from the cache.\n\t * This can be handy if you want to close file descriptors or do other\n\t * cleanup tasks when items are no longer accessible. Called with `key, value`.\n\t * It's called before actually removing the item from the internal cache,\n\t * so if you want to immediately put it back in, you'll have to do that in\n\t * a `nextTick` or `setTimeout` callback or it won't do anything.\n\t */\n\tdispose?(key: K, value: V): void;\n\n\t/**\n\t * By default, if you set a `maxAge`, it'll only actually pull stale items\n\t * out of the cache when you `get(key)`. (That is, it's not pre-emptively\n\t * doing a `setTimeout` or anything.) If you set `stale:true`, it'll return\n\t * the stale value before deleting it. If you don't set this, then it'll\n\t * return `undefined` when you try to get a stale entry,\n\t * as if it had already been deleted.\n\t */\n\tstale?: boolean;\n\n\t/**\n\t * By default, if you set a `dispose()` method, then it'll be called whenever\n\t * a `set()` operation overwrites an existing key. If you set this option,\n\t * `dispose()` will only be called when a key falls out of the cache,\n\t * not when it is overwritten.\n\t */\n\tnoDisposeOnSet?: boolean;\n\n\t/**\n\t * When using time-expiring entries with `maxAge`, setting this to `true` will make each\n\t * item's effective time update to the current time whenever it is retrieved from cache,\n\t * causing it to not expire. (It can still fall out of cache based on recency of use, of\n\t * course.)\n\t */\n\tupdateAgeOnGet?: boolean;\n}\n\nexport interface ILruEntry<K, V>\n{\n\tk: K;\n\tv: V;\n\te: number;\n}\n\nexport type INode<K, V> = Yallist<Entry<K, V>>[\"head\"]\n\nexport type IFn<K, V> = (this: LRUCache<K, V>, value: V, key: K, self: LRUCache<K, V>) => void\n"]}